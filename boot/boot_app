#!/bin/sh
# --------------------------------------------------------------
# This script starts a system service rasberry pi device
# --------------------------------------------------------------
THIS_DIR=$(cd $(dirname $BASH_SOURCE[0]) && pwd)

OPSEC_DIR=$(cd $THIS_DIR && cd .. && pwd)
OPSEC_USER="${OPSEC_USER:-admin}"
OPSEC_LANG="${OPSEC_LANG:-$LANG}"
OPSEC_FILE=$OPSEC_DIR/.profile.sh

echo "========================= OpSec tools starting up ======================"

echo "OpSec: Init LED control..."
source $THIS_DIR/init_led.sh

echo "OpSec: Loading config ..."
source $THIS_DIR/init_config.sh

# Create bash script which could be altered from /home/admin/.profile
# --------------------------------------------------------------
cat << EOF >> $OPSEC_FILE
#!/bin/bash
OPSEC_DIR=$OPSEC_DIR
OPSEC_LANG=$OPSEC_LANG

$(declare -p ledtrigger | cut -d" " -f3)
$(declare -f led_blink)
$(declare -f onLogin)
EOF
chown $OPSEC_USER:$OPSEC_USER $OPSEC_FILE
# --------------------------------------------------------------


echo "OpSec: Initializing USB gadget ..."
source $THIS_DIR/init_usb.sh
init_usb

echo "OpSec: Checking for WiFi capabilities ..."
source $THIS_DIR/init_wifi.sh
check_wifi

if $WIFI; then
	echo "OpSec: Seems WiFi module is present!"
	iw reg set $WIFI_REG

	source $THIS_DIR/init_wifi_nexmon.sh
	if $WIFI_NEXMON; then
		# swap firmware and driver
		WIFI_activate_nexmon
	fi


	# start WIFI client
	if $WIFI_CLIENT; then
		# try to connect to existing WiFi according to the config
		sleep 1 # pause to make new reg domain accessible in scan
		if start_wifi_client; then
			WIFI_CLIENT_CONNECTION_SUCCESS=true
		else
			echo "OpSec: Join present WiFi didn't succeed, failing over to access point mode"
			WIFI_CLIENT_CONNECTION_SUCCESS=false
		fi
	fi
		
	# start ACCESS POINT if needed
	# - if WiFi client mode is disabled and ACCESPOINT mode is enabled
	# - if WiFi client mode is enabled, but failed and ACCESPOINT mode is enabled
	if $WIFI_ACCESSPOINT && ( ! $WIFI_CLIENT_CONNECTION_SUCCESS || ! $WIFI_CLIENT); then
		start_wifi_accesspoint
		
		# check if acces point is up and trigger callback
		# Warning!!! This uses the SSID and isn't tested against hidden SSID configurations
		(
			AP_DOWN=true
			while $AP_DOWN; do
				iw dev | grep -q -E "ssid $WIFI_ACCESSPOINT_NAME"; res=$?
				if [ $res == 0 ]; then 
					AP_DOWN=false

				        if $WIFI_ACCESSPOINT_KARMA && $WIFI_NEXMON; then
						WIFI_enable_KARMA
				        fi
				        if $WIFI_ACCESSPOINT_KARMA_LOUD && $WIFI_NEXMON; then
						WIFI_enable_KARMA_LOUD
				        fi

					declare -f onAccessPointUp > /dev/null && onAccessPointUp # run only once
				fi
			done
		)&
	fi
fi


detect_usb_hostmode # creates OTG_MODE=true if OpSec is in OTG mode

# early out if OpSec is used in OTG mode
if $OTG_MODE; then
	echo "As OpSec is detected to run in Host (interactive) mode, we abort device setup now!"
	exit
else
	echo "OpSec: ... USB gadget initialized"
fi

# check if ethernet over USB should be used
if $USB_RNDIS || $USB_ECM; then 
	USB_ETHERNET=true 
fi

# change hostname to make OpSec resolveable on "name.local"
#if $WIFI || $USB_ETHERNET; then
#	hostname="MAME82-OpSec"
#
#	hostname $hostname
#	echo $hostname > /etc/hostname
#
#	# add to /etc/hosts
#	if ! grep -q -E "^127\.0\.0\.1 $hostname\$" /etc/hosts; then
#	        echo "127.0.0.1 $hostname" >> /etc/hosts
#	fi
#fi


# if ethernet over USB is in use, detect active interface and start DHCP (all as background job)
if $USB_ETHERNET; then
	echo "OpSec: Initializing Ethernet over USB..."
	source $THIS_DIR/init_usb_ethernet.sh
	(
		detect_active_interface

		if [ "$active_interface" != "none" ]; then 
			create_DHCP_config
			dnsmasq -C /tmp/dnsmasq_usb_eth.conf

			# callback onNetworkUp() of payload script
			declare -f onNetworkUp > /dev/null && onNetworkUp

			# wait for client to receive DHCP lease
			target_ip=""
			while [ "$target_ip" == "" ]; do
				target_ip=$(cat /tmp/dnsmasq.leases | cut -d" " -f3)
				target_name=$(cat /tmp/dnsmasq.leases | awk '{print $4}')
				sleep 0.2
			done

			# callback onNetworkGotIP() of payload script 
			declare -f onTargetGotIP > /dev/null && onTargetGotIP
		fi
	)&
fi

# take care of AutoSSH reachback
source $THIS_DIR/init_autossh.sh
start_autossh # start_autossh takes care of checking AUTOSSH_ENABLED

if $USE_HID_MOUSE; then
	# import mouse functions
	source $THIS_DIR/init_hid_mouse.sh
	declare -f outmouse >> $OPSEC_FILE
	chown $OPSEC_USER:$OPSEC_USER $OPSEC_FILE
fi

if $USE_HID; then
	# import keyboard functions
	source $THIS_DIR/init_hid_keyboard.sh
	
	declare -f outhid >> $OPSEC_FILE
	declare -f duckhid >> $OPSEC_FILE
	chown $OPSEC_USER:$OPSEC_USER $OPSEC_FILE

	# if HID keyboard should be tested for readyness, do it (triggers "onKeyboardUp" callback of payload)
	if $HID_KEYBOARD_TEST; then
#		detect_HID_keyboard&
		(
			echo "Waiting for HID keyboard to be usable..."
			# blocking read of LED status
			python -c "with open('/dev/hidg0','rb') as f:  print ord(f.read(1))"
			# fire 'onKeyboardUp' after read has succeeded
			declare -f onKeyboardUp > /dev/null && onKeyboardUp
		)&
	fi
fi

# trigger callback for on boot finished
#(
#	declare -f onBootFinished > /dev/null && onBootFinished # run only once
#)&
