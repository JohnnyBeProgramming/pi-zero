#!/bin/sh
# --------------------------------------------------------------
# This script starts a system service rasberry pi device
# --------------------------------------------------------------
THIS_DIR=$(cd $(dirname $0) && pwd)

OPSEC_DIR="$HOME/app"
OPSEC_USER="${OPSEC_USER:-admin}"
OPSEC_LANG="${OPSEC_LANG:-$LANG}"
OPSEC_FILE=$OPSEC_DIR/.profile.sh

echo "========================= OpSec tools starting up ======================"

echo "OpSec: Loading config ..."
source $THIS_DIR/init_config.sh

# Create bash script which could be altered from /home/admin/.profile
# --------------------------------------------------------------
cat << EOF >> $OPSEC_FILE
#!/bin/bash
OPSEC_DIR=$OPSEC_DIR
OPSEC_LANG=$OPSEC_LANG

$(declare -f onLogin)
EOF
chown $OPSEC_USER:$OPSEC_USER $OPSEC_FILE
# --------------------------------------------------------------

echo "OpSec: Checking for WiFi capabilities ..."
source $THIS_DIR/init_wifi.sh
check_wifi

if $WIFI; then
	echo "OpSec: Seems WiFi module is present!"
	iw reg set $WIFI_REG

	# start WIFI client
	if $WIFI_CLIENT; then
		# try to connect to existing WiFi according to the config
		sleep 1 # pause to make new reg domain accessible in scan
		if start_wifi_client; then
			WIFI_CLIENT_CONNECTION_SUCCESS=true
		else
			echo "OpSec: Join present WiFi didn't succeed, failing over to access point mode"
			WIFI_CLIENT_CONNECTION_SUCCESS=false
		fi
	fi
		
	# start ACCESS POINT if needed
	# - if WiFi client mode is disabled and ACCESPOINT mode is enabled
	# - if WiFi client mode is enabled, but failed and ACCESPOINT mode is enabled
	if $WIFI_ACCESSPOINT && ( ! $WIFI_CLIENT_CONNECTION_SUCCESS || ! $WIFI_CLIENT); then
		start_wifi_accesspoint
		
		# check if acces point is up and trigger callback
		# Warning!!! This uses the SSID and isn't tested against hidden SSID configurations
		(
			AP_DOWN=true
			while $AP_DOWN; do
				iw dev | grep -q -E "ssid $WIFI_ACCESSPOINT_NAME"; res=$?
				if [ $res == 0 ]; then 
					AP_DOWN=false

				        if $WIFI_ACCESSPOINT_KARMA && $WIFI_NEXMON; then
						WIFI_enable_KARMA
				        fi
				        if $WIFI_ACCESSPOINT_KARMA_LOUD && $WIFI_NEXMON; then
						WIFI_enable_KARMA_LOUD
				        fi

					declare -f onAccessPointUp > /dev/null && onAccessPointUp # run only once
				fi
			done
		)&
	fi
fi


detect_usb_hostmode # creates OTG_MODE=true if OpSec is in OTG mode

# early out if OpSec is used in OTG mode
if $OTG_MODE; then
	echo "As OpSec is detected to run in Host (interactive) mode, we abort device setup now!"
	exit
else
	echo "OpSec: ... USB gadget initialized"
fi

# check if ethernet over USB should be used
if $USB_RNDIS || $USB_ECM; then 
	USB_ETHERNET=true 
fi

# if ethernet over USB is in use, detect active interface and start DHCP (all as background job)
if $USB_ETHERNET; then
	echo "OpSec: Initializing Ethernet over USB..."
	source $THIS_DIR/init_usb_ethernet.sh
	(
		detect_active_interface

		if [ "$active_interface" != "none" ]; then 
			create_DHCP_config
			dnsmasq -C /tmp/dnsmasq_usb_eth.conf

			# callback onNetworkUp() of payload script
			declare -f onNetworkUp > /dev/null && onNetworkUp

			# wait for client to receive DHCP lease
			target_ip=""
			while [ "$target_ip" == "" ]; do
				target_ip=$(cat /tmp/dnsmasq.leases | cut -d" " -f3)
				target_name=$(cat /tmp/dnsmasq.leases | awk '{print $4}')
				sleep 0.2
			done

			# callback onNetworkGotIP() of payload script 
			declare -f onTargetGotIP > /dev/null && onTargetGotIP
		fi
	)&
fi

# trigger callback for on boot finished
(
	declare -f onBootFinished > /dev/null && echo "Boot of application finished" # run only once
)&
